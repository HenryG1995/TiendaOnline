"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.object.create.js");
require("core-js/modules/es.object.define-property.js");
require("core-js/modules/es.symbol.to-primitive.js");
require("core-js/modules/es.date.to-primitive.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.number.constructor.js");
require("core-js/modules/es.array.is-array.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.weak-map.js");
require("core-js/modules/es.object.get-own-property-descriptor.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
require("core-js/modules/es.array.map.js");
require("core-js/modules/es.string.starts-with.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.array.for-each.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.for-each.js");
require("core-js/modules/es.date.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.array.find.js");
require("core-js/modules/es.object.set-prototype-of.js");
require("core-js/modules/es.function.bind.js");
require("core-js/modules/es.object.get-prototype-of.js");
var _child_process = require("child_process");
var _fs = require("fs");
var _os = require("os");
var path = _interopRequireWildcard(require("path"));
var _events = _interopRequireDefault(require("events"));
var _types = require("./types");
var _project_workspace = _interopRequireDefault(require("./project_workspace"));
var _Process = require("./Process");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
// This class represents the running process, and
// passes out events when it understands what data is being
// pass sent out of the process
var Runner = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Runner, _EventEmitter);
  var _super = _createSuper(Runner);
  // $FlowIgnore[value-as-type]

  // $FlowIgnore[value-as-type]

  // $FlowIgnore[value-as-type]
  function Runner(workspace, options) {
    var _this;
    _classCallCheck(this, Runner);
    _this = _super.call(this);
    _this._createProcess = options && options.createProcess || _Process.createProcess;
    _this.options = options || {};
    _this.workspace = workspace;
    _this.outputPath = path.join((0, _os.tmpdir)(), "jest_runner_".concat(_this.workspace.outputFileSuffix || '', ".json"));
    _this.prevMessageTypes = [];
    _this._exited = false;
    return _this;
  }
  _createClass(Runner, [{
    key: "__convertDashedArgs",
    value: function __convertDashedArgs(args) {
      if (!this.workspace.useDashedArgs) {
        return args;
      }
      return args.map(function (arg) {
        return arg && arg.startsWith('--') && arg.length > 2 ? arg.replace(/(\B)([A-Z])/gm, '-$2').toLowerCase() : arg;
      });
    }
  }, {
    key: "_getArgs",
    value: function _getArgs() {
      if (this.options.args && this.options.args.replace) {
        return this.options.args.skipConversion ? this.options.args.args : this.__convertDashedArgs(this.options.args.args);
      }

      // Handle the arg change on v18
      var belowEighteen = this.workspace.localJestMajorVersion < 18;
      var outputArg = belowEighteen ? '--jsonOutputFile' : '--outputFile';
      var args = ['--testLocationInResults', '--json', '--useStderr', outputArg, this.outputPath];
      if (this.watchMode) {
        args.push(this.watchAll ? '--watchAll' : '--watch');
      }
      if (this.options.testNamePattern) {
        args.push('--testNamePattern', this.options.testNamePattern);
      }
      if (this.options.testFileNamePattern) {
        args.push(this.options.testFileNamePattern);
      }
      if (this.workspace.collectCoverage === true) {
        args.push('--coverage');
      }
      if (this.workspace.collectCoverage === false) {
        args.push('--no-coverage');
      }
      if (this.options.noColor === true) {
        args.push('--no-color');
      }
      if (this.options.reporters) {
        this.options.reporters.forEach(function (reporter) {
          args.push('--reporters', reporter);
        });
      }
      if (this.options.args) {
        var _args;
        (_args = args).push.apply(_args, _toConsumableArray(this.options.args.args));
      }
      args = this.__convertDashedArgs(args);
      return args;
    }
  }, {
    key: "start",
    value: function start() {
      var _this2 = this;
      var watchMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var watchAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (this.debugprocess) {
        return;
      }
      this.watchMode = watchMode;
      this.watchAll = watchAll;
      var args = this._getArgs();
      var debugprocess = this._createProcess(this.workspace, args);
      this.debugprocess = debugprocess;
      debugprocess.stdout.on('data', function (data) {
        _this2._parseOutput(data, false);
      });
      debugprocess.stderr.on('data', function (data) {
        // jest 23 could send test results message to stderr
        // see https://github.com/facebook/jest/pull/4858
        _this2._parseOutput(data, true);
      });
      debugprocess.on('exit', function (code, signal) {
        _this2._exited = true;

        // this is mainly for backward compatibility, should be deprecated soon
        _this2.emit('debuggerProcessExit');
        _this2.emit('processExit', code, signal);
        _this2.prevMessageTypes.length = 0;
      });
      debugprocess.on('error', function (error) {
        _this2.emit('terminalError', "Process failed: ".concat(error.message));
        _this2.prevMessageTypes.length = 0;
      });
      debugprocess.on('close', function (code, signal) {
        // this is mainly for backward compatibility, should be deprecated soon
        _this2.emit('debuggerProcessExit');
        _this2.emit('processClose', code, signal);
        _this2.prevMessageTypes.length = 0;
      });
    }

    /**
     * parse the stdin/out stream buffer for recognized messages.
     *
     * note: if these messages coming in in separate chucks, we might not be able to
     * resolve it properly. While there haven't been much evidence of such scenario,
     * it's worth to note that it could and we might need to buffer them in that case.
     * see https://github.com/jest-community/jest-editor-support/pull/9#pullrequestreview-231888752
     *
     * @param {Buffer} data
     * @param {boolean} isStdErr
     * @returns {MessageType}
     * @memberof Runner
     */
  }, {
    key: "_parseOutput",
    value: function _parseOutput(data, isStdErr) {
      var _this3 = this;
      var msgType = this.findMessageType(data);
      switch (msgType) {
        case _types.messageTypes.testResults:
          this.emit('executableStdErr', data, {
            type: msgType
          });
          (0, _fs.readFile)(this.outputPath, 'utf8', function (err, _data) {
            if (err) {
              var message = "JSON report not found at ".concat(_this3.outputPath);
              _this3.emit('terminalError', message);
            } else {
              var noTestsFound = _this3.doResultsFollowNoTestsFoundMessage();
              _this3.emit('executableJSON', JSON.parse(_data), {
                noTestsFound: noTestsFound
              });
            }
          });
          this.prevMessageTypes.length = 0;
          break;
        case _types.messageTypes.watchUsage:
        case _types.messageTypes.noTests:
          this.prevMessageTypes.push(msgType);
          this.emit('executableStdErr', data, {
            type: msgType
          });
          break;
        default:
          // no special action needed, just report the output by its source
          if (isStdErr) {
            this.emit('executableStdErr', data, {
              type: msgType
            });
          } else {
            // remove clear screen escape sequence
            this.emit('executableOutput', data.toString().replace('[2J[H', ''));
          }
          this.prevMessageTypes.length = 0;
          break;
      }
      return msgType;
    }
  }, {
    key: "runJestWithUpdateForSnapshots",
    value: function runJestWithUpdateForSnapshots(completion, args) {
      var defaultArgs = ['--updateSnapshot'];
      var updateProcess = this._createProcess(this.workspace, [].concat(defaultArgs, _toConsumableArray(args || [])));
      updateProcess.on('close', function () {
        completion();
      });
    }
  }, {
    key: "closeProcess",
    value: function closeProcess() {
      if (!this.debugprocess || this._exited) {
        // eslint-disable-next-line no-console
        console.log("process has not started or already exited");
        return;
      }
      if (process.platform === 'win32') {
        // Windows doesn't exit the process when it should.
        (0, _child_process.spawn)('taskkill', ['/pid', "".concat(this.debugprocess.pid), '/T', '/F']);
      } else {
        try {
          // kill all process with the same PGID, i.e.
          // as a detached process, it is the same as the PID of the leader process.
          process.kill(-this.debugprocess.pid);
        } catch (e) {
          var _this$debugprocess, _this$debugprocess2;
          // if anything goes wrong, fallback to the old benavior
          // knowing this could leave orphan process...
          // eslint-disable-next-line no-console
          console.warn("failed to kill process group, this could leave some orphan process whose ppid=".concat(((_this$debugprocess = this.debugprocess) === null || _this$debugprocess === void 0 ? void 0 : _this$debugprocess.pid) || 'process-non-exist', ". error="), e);
          (_this$debugprocess2 = this.debugprocess) === null || _this$debugprocess2 === void 0 ? void 0 : _this$debugprocess2.kill();
        }
      }
      this.debugprocess = undefined;
    }

    // eslint-disable-next-line class-methods-use-this
  }, {
    key: "findMessageType",
    value: function findMessageType(buf) {
      var noTestRegex = /No tests found related to files changed since ((last commit)|("[a-z0-9]+"))./;
      var watchUsageRegex = /^\s*Watch Usage\b/;
      var testResultsRegex = /Test results written to/;
      var checks = [{
        regex: testResultsRegex,
        messageType: _types.messageTypes.testResults
      }, {
        regex: noTestRegex,
        messageType: _types.messageTypes.noTests
      }, {
        regex: watchUsageRegex,
        messageType: _types.messageTypes.watchUsage
      }];
      var str = buf.toString('utf8');
      var match = checks.find(function (_ref) {
        var regex = _ref.regex;
        return regex.test(str);
      });
      return match ? match.messageType : _types.messageTypes.unknown;
    }
  }, {
    key: "doResultsFollowNoTestsFoundMessage",
    value: function doResultsFollowNoTestsFoundMessage() {
      if (this.prevMessageTypes.length === 1) {
        return this.prevMessageTypes[0] === _types.messageTypes.noTests;
      }
      if (this.prevMessageTypes.length === 2) {
        return this.prevMessageTypes[0] === _types.messageTypes.noTests && this.prevMessageTypes[1] === _types.messageTypes.watchUsage;
      }
      return false;
    }
  }]);
  return Runner;
}(_events["default"]);
exports["default"] = Runner;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJSdW5uZXIiLCJ3b3Jrc3BhY2UiLCJvcHRpb25zIiwiX2NyZWF0ZVByb2Nlc3MiLCJjcmVhdGVQcm9jZXNzIiwib3V0cHV0UGF0aCIsInBhdGgiLCJqb2luIiwidG1wZGlyIiwib3V0cHV0RmlsZVN1ZmZpeCIsInByZXZNZXNzYWdlVHlwZXMiLCJfZXhpdGVkIiwiYXJncyIsInVzZURhc2hlZEFyZ3MiLCJtYXAiLCJhcmciLCJzdGFydHNXaXRoIiwibGVuZ3RoIiwicmVwbGFjZSIsInRvTG93ZXJDYXNlIiwic2tpcENvbnZlcnNpb24iLCJfX2NvbnZlcnREYXNoZWRBcmdzIiwiYmVsb3dFaWdodGVlbiIsImxvY2FsSmVzdE1ham9yVmVyc2lvbiIsIm91dHB1dEFyZyIsIndhdGNoTW9kZSIsInB1c2giLCJ3YXRjaEFsbCIsInRlc3ROYW1lUGF0dGVybiIsInRlc3RGaWxlTmFtZVBhdHRlcm4iLCJjb2xsZWN0Q292ZXJhZ2UiLCJub0NvbG9yIiwicmVwb3J0ZXJzIiwiZm9yRWFjaCIsInJlcG9ydGVyIiwiZGVidWdwcm9jZXNzIiwiX2dldEFyZ3MiLCJzdGRvdXQiLCJvbiIsImRhdGEiLCJfcGFyc2VPdXRwdXQiLCJzdGRlcnIiLCJjb2RlIiwic2lnbmFsIiwiZW1pdCIsImVycm9yIiwibWVzc2FnZSIsImlzU3RkRXJyIiwibXNnVHlwZSIsImZpbmRNZXNzYWdlVHlwZSIsIm1lc3NhZ2VUeXBlcyIsInRlc3RSZXN1bHRzIiwidHlwZSIsInJlYWRGaWxlIiwiZXJyIiwiX2RhdGEiLCJub1Rlc3RzRm91bmQiLCJkb1Jlc3VsdHNGb2xsb3dOb1Rlc3RzRm91bmRNZXNzYWdlIiwiSlNPTiIsInBhcnNlIiwid2F0Y2hVc2FnZSIsIm5vVGVzdHMiLCJ0b1N0cmluZyIsImNvbXBsZXRpb24iLCJkZWZhdWx0QXJncyIsInVwZGF0ZVByb2Nlc3MiLCJjb25zb2xlIiwibG9nIiwicHJvY2VzcyIsInBsYXRmb3JtIiwic3Bhd24iLCJwaWQiLCJraWxsIiwiZSIsIndhcm4iLCJ1bmRlZmluZWQiLCJidWYiLCJub1Rlc3RSZWdleCIsIndhdGNoVXNhZ2VSZWdleCIsInRlc3RSZXN1bHRzUmVnZXgiLCJjaGVja3MiLCJyZWdleCIsIm1lc3NhZ2VUeXBlIiwic3RyIiwibWF0Y2giLCJmaW5kIiwidGVzdCIsInVua25vd24iLCJFdmVudEVtaXR0ZXIiXSwic291cmNlcyI6WyIuLi9zcmMvUnVubmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQge0NoaWxkUHJvY2Vzcywgc3Bhd259IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHtyZWFkRmlsZX0gZnJvbSAnZnMnO1xuaW1wb3J0IHt0bXBkaXJ9IGZyb20gJ29zJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQge21lc3NhZ2VUeXBlc30gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgdHlwZSB7T3B0aW9ucywgTWVzc2FnZVR5cGV9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IFByb2plY3RXb3Jrc3BhY2UgZnJvbSAnLi9wcm9qZWN0X3dvcmtzcGFjZSc7XG5pbXBvcnQge2NyZWF0ZVByb2Nlc3N9IGZyb20gJy4vUHJvY2Vzcyc7XG5cbi8vIFRoaXMgY2xhc3MgcmVwcmVzZW50cyB0aGUgcnVubmluZyBwcm9jZXNzLCBhbmRcbi8vIHBhc3NlcyBvdXQgZXZlbnRzIHdoZW4gaXQgdW5kZXJzdGFuZHMgd2hhdCBkYXRhIGlzIGJlaW5nXG4vLyBwYXNzIHNlbnQgb3V0IG9mIHRoZSBwcm9jZXNzXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdW5uZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBkZWJ1Z3Byb2Nlc3M6ID9DaGlsZFByb2Nlc3M7XG5cbiAgb3V0cHV0UGF0aDogc3RyaW5nO1xuXG4gIC8vICRGbG93SWdub3JlW3ZhbHVlLWFzLXR5cGVdXG4gIHdvcmtzcGFjZTogUHJvamVjdFdvcmtzcGFjZTtcblxuICAvLyAkRmxvd0lnbm9yZVt2YWx1ZS1hcy10eXBlXVxuICBfY3JlYXRlUHJvY2VzczogKHdvcmtzcGFjZTogUHJvamVjdFdvcmtzcGFjZSwgYXJnczogQXJyYXk8c3RyaW5nPikgPT4gQ2hpbGRQcm9jZXNzO1xuXG4gIHdhdGNoTW9kZTogYm9vbGVhbjtcblxuICB3YXRjaEFsbDogYm9vbGVhbjtcblxuICBvcHRpb25zOiBPcHRpb25zO1xuXG4gIHByZXZNZXNzYWdlVHlwZXM6IE1lc3NhZ2VUeXBlW107XG5cbiAgX2V4aXRlZDogYm9vbGVhbjtcblxuICAvLyAkRmxvd0lnbm9yZVt2YWx1ZS1hcy10eXBlXVxuICBjb25zdHJ1Y3Rvcih3b3Jrc3BhY2U6IFByb2plY3RXb3Jrc3BhY2UsIG9wdGlvbnM/OiBPcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2NyZWF0ZVByb2Nlc3MgPSAob3B0aW9ucyAmJiBvcHRpb25zLmNyZWF0ZVByb2Nlc3MpIHx8IGNyZWF0ZVByb2Nlc3M7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLndvcmtzcGFjZSA9IHdvcmtzcGFjZTtcbiAgICB0aGlzLm91dHB1dFBhdGggPSBwYXRoLmpvaW4odG1wZGlyKCksIGBqZXN0X3J1bm5lcl8ke3RoaXMud29ya3NwYWNlLm91dHB1dEZpbGVTdWZmaXggfHwgJyd9Lmpzb25gKTtcbiAgICB0aGlzLnByZXZNZXNzYWdlVHlwZXMgPSBbXTtcbiAgICB0aGlzLl9leGl0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIF9fY29udmVydERhc2hlZEFyZ3MoYXJnczogc3RyaW5nW10pOiBzdHJpbmdbXSB7XG4gICAgaWYgKCF0aGlzLndvcmtzcGFjZS51c2VEYXNoZWRBcmdzKSB7XG4gICAgICByZXR1cm4gYXJncztcbiAgICB9XG5cbiAgICByZXR1cm4gYXJncy5tYXAoKGFyZykgPT5cbiAgICAgIGFyZyAmJiBhcmcuc3RhcnRzV2l0aCgnLS0nKSAmJiBhcmcubGVuZ3RoID4gMiA/IGFyZy5yZXBsYWNlKC8oXFxCKShbQS1aXSkvZ20sICctJDInKS50b0xvd2VyQ2FzZSgpIDogYXJnXG4gICAgKTtcbiAgfVxuXG4gIF9nZXRBcmdzKCk6IHN0cmluZ1tdIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmFyZ3MgJiYgdGhpcy5vcHRpb25zLmFyZ3MucmVwbGFjZSkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hcmdzLnNraXBDb252ZXJzaW9uXG4gICAgICAgID8gdGhpcy5vcHRpb25zLmFyZ3MuYXJnc1xuICAgICAgICA6IHRoaXMuX19jb252ZXJ0RGFzaGVkQXJncyh0aGlzLm9wdGlvbnMuYXJncy5hcmdzKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgdGhlIGFyZyBjaGFuZ2Ugb24gdjE4XG4gICAgY29uc3QgYmVsb3dFaWdodGVlbiA9IHRoaXMud29ya3NwYWNlLmxvY2FsSmVzdE1ham9yVmVyc2lvbiA8IDE4O1xuICAgIGNvbnN0IG91dHB1dEFyZyA9IGJlbG93RWlnaHRlZW4gPyAnLS1qc29uT3V0cHV0RmlsZScgOiAnLS1vdXRwdXRGaWxlJztcbiAgICBsZXQgYXJncyA9IFsnLS10ZXN0TG9jYXRpb25JblJlc3VsdHMnLCAnLS1qc29uJywgJy0tdXNlU3RkZXJyJywgb3V0cHV0QXJnLCB0aGlzLm91dHB1dFBhdGhdO1xuICAgIGlmICh0aGlzLndhdGNoTW9kZSkge1xuICAgICAgYXJncy5wdXNoKHRoaXMud2F0Y2hBbGwgPyAnLS13YXRjaEFsbCcgOiAnLS13YXRjaCcpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnRlc3ROYW1lUGF0dGVybikge1xuICAgICAgYXJncy5wdXNoKCctLXRlc3ROYW1lUGF0dGVybicsIHRoaXMub3B0aW9ucy50ZXN0TmFtZVBhdHRlcm4pO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnRlc3RGaWxlTmFtZVBhdHRlcm4pIHtcbiAgICAgIGFyZ3MucHVzaCh0aGlzLm9wdGlvbnMudGVzdEZpbGVOYW1lUGF0dGVybik7XG4gICAgfVxuICAgIGlmICh0aGlzLndvcmtzcGFjZS5jb2xsZWN0Q292ZXJhZ2UgPT09IHRydWUpIHtcbiAgICAgIGFyZ3MucHVzaCgnLS1jb3ZlcmFnZScpO1xuICAgIH1cbiAgICBpZiAodGhpcy53b3Jrc3BhY2UuY29sbGVjdENvdmVyYWdlID09PSBmYWxzZSkge1xuICAgICAgYXJncy5wdXNoKCctLW5vLWNvdmVyYWdlJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMubm9Db2xvciA9PT0gdHJ1ZSkge1xuICAgICAgYXJncy5wdXNoKCctLW5vLWNvbG9yJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMucmVwb3J0ZXJzKSB7XG4gICAgICB0aGlzLm9wdGlvbnMucmVwb3J0ZXJzLmZvckVhY2goKHJlcG9ydGVyKSA9PiB7XG4gICAgICAgIGFyZ3MucHVzaCgnLS1yZXBvcnRlcnMnLCByZXBvcnRlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hcmdzKSB7XG4gICAgICBhcmdzLnB1c2goLi4udGhpcy5vcHRpb25zLmFyZ3MuYXJncyk7XG4gICAgfVxuICAgIGFyZ3MgPSB0aGlzLl9fY29udmVydERhc2hlZEFyZ3MoYXJncyk7XG5cbiAgICByZXR1cm4gYXJncztcbiAgfVxuXG4gIHN0YXJ0KHdhdGNoTW9kZTogYm9vbGVhbiA9IHRydWUsIHdhdGNoQWxsOiBib29sZWFuID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5kZWJ1Z3Byb2Nlc3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLndhdGNoTW9kZSA9IHdhdGNoTW9kZTtcbiAgICB0aGlzLndhdGNoQWxsID0gd2F0Y2hBbGw7XG5cbiAgICBjb25zdCBhcmdzID0gdGhpcy5fZ2V0QXJncygpO1xuICAgIGNvbnN0IGRlYnVncHJvY2VzcyA9IHRoaXMuX2NyZWF0ZVByb2Nlc3ModGhpcy53b3Jrc3BhY2UsIGFyZ3MpO1xuICAgIHRoaXMuZGVidWdwcm9jZXNzID0gZGVidWdwcm9jZXNzO1xuICAgIGRlYnVncHJvY2Vzcy5zdGRvdXQub24oJ2RhdGEnLCAoZGF0YTogQnVmZmVyKSA9PiB7XG4gICAgICB0aGlzLl9wYXJzZU91dHB1dChkYXRhLCBmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBkZWJ1Z3Byb2Nlc3Muc3RkZXJyLm9uKCdkYXRhJywgKGRhdGE6IEJ1ZmZlcikgPT4ge1xuICAgICAgLy8gamVzdCAyMyBjb3VsZCBzZW5kIHRlc3QgcmVzdWx0cyBtZXNzYWdlIHRvIHN0ZGVyclxuICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9qZXN0L3B1bGwvNDg1OFxuICAgICAgdGhpcy5fcGFyc2VPdXRwdXQoZGF0YSwgdHJ1ZSk7XG4gICAgfSk7XG4gICAgZGVidWdwcm9jZXNzLm9uKCdleGl0JywgKGNvZGU6IG51bWJlciB8IG51bGwsIHNpZ25hbDogc3RyaW5nIHwgbnVsbCkgPT4ge1xuICAgICAgdGhpcy5fZXhpdGVkID0gdHJ1ZTtcblxuICAgICAgLy8gdGhpcyBpcyBtYWlubHkgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHNob3VsZCBiZSBkZXByZWNhdGVkIHNvb25cbiAgICAgIHRoaXMuZW1pdCgnZGVidWdnZXJQcm9jZXNzRXhpdCcpO1xuXG4gICAgICB0aGlzLmVtaXQoJ3Byb2Nlc3NFeGl0JywgY29kZSwgc2lnbmFsKTtcbiAgICAgIHRoaXMucHJldk1lc3NhZ2VUeXBlcy5sZW5ndGggPSAwO1xuICAgIH0pO1xuXG4gICAgZGVidWdwcm9jZXNzLm9uKCdlcnJvcicsIChlcnJvcjogRXJyb3IpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgndGVybWluYWxFcnJvcicsIGBQcm9jZXNzIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgdGhpcy5wcmV2TWVzc2FnZVR5cGVzLmxlbmd0aCA9IDA7XG4gICAgfSk7XG5cbiAgICBkZWJ1Z3Byb2Nlc3Mub24oJ2Nsb3NlJywgKGNvZGU6IG51bWJlciB8IG51bGwsIHNpZ25hbDogc3RyaW5nIHwgbnVsbCkgPT4ge1xuICAgICAgLy8gdGhpcyBpcyBtYWlubHkgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHNob3VsZCBiZSBkZXByZWNhdGVkIHNvb25cbiAgICAgIHRoaXMuZW1pdCgnZGVidWdnZXJQcm9jZXNzRXhpdCcpO1xuXG4gICAgICB0aGlzLmVtaXQoJ3Byb2Nlc3NDbG9zZScsIGNvZGUsIHNpZ25hbCk7XG4gICAgICB0aGlzLnByZXZNZXNzYWdlVHlwZXMubGVuZ3RoID0gMDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBwYXJzZSB0aGUgc3RkaW4vb3V0IHN0cmVhbSBidWZmZXIgZm9yIHJlY29nbml6ZWQgbWVzc2FnZXMuXG4gICAqXG4gICAqIG5vdGU6IGlmIHRoZXNlIG1lc3NhZ2VzIGNvbWluZyBpbiBpbiBzZXBhcmF0ZSBjaHVja3MsIHdlIG1pZ2h0IG5vdCBiZSBhYmxlIHRvXG4gICAqIHJlc29sdmUgaXQgcHJvcGVybHkuIFdoaWxlIHRoZXJlIGhhdmVuJ3QgYmVlbiBtdWNoIGV2aWRlbmNlIG9mIHN1Y2ggc2NlbmFyaW8sXG4gICAqIGl0J3Mgd29ydGggdG8gbm90ZSB0aGF0IGl0IGNvdWxkIGFuZCB3ZSBtaWdodCBuZWVkIHRvIGJ1ZmZlciB0aGVtIGluIHRoYXQgY2FzZS5cbiAgICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qZXN0LWNvbW11bml0eS9qZXN0LWVkaXRvci1zdXBwb3J0L3B1bGwvOSNwdWxscmVxdWVzdHJldmlldy0yMzE4ODg3NTJcbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGFcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1N0ZEVyclxuICAgKiBAcmV0dXJucyB7TWVzc2FnZVR5cGV9XG4gICAqIEBtZW1iZXJvZiBSdW5uZXJcbiAgICovXG4gIF9wYXJzZU91dHB1dChkYXRhOiBCdWZmZXIsIGlzU3RkRXJyOiBib29sZWFuKTogTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0IG1zZ1R5cGUgPSB0aGlzLmZpbmRNZXNzYWdlVHlwZShkYXRhKTtcbiAgICBzd2l0Y2ggKG1zZ1R5cGUpIHtcbiAgICAgIGNhc2UgbWVzc2FnZVR5cGVzLnRlc3RSZXN1bHRzOlxuICAgICAgICB0aGlzLmVtaXQoJ2V4ZWN1dGFibGVTdGRFcnInLCBkYXRhLCB7XG4gICAgICAgICAgdHlwZTogbXNnVHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJlYWRGaWxlKHRoaXMub3V0cHV0UGF0aCwgJ3V0ZjgnLCAoZXJyLCBfZGF0YSkgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgSlNPTiByZXBvcnQgbm90IGZvdW5kIGF0ICR7dGhpcy5vdXRwdXRQYXRofWA7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3Rlcm1pbmFsRXJyb3InLCBtZXNzYWdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgbm9UZXN0c0ZvdW5kID0gdGhpcy5kb1Jlc3VsdHNGb2xsb3dOb1Rlc3RzRm91bmRNZXNzYWdlKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2V4ZWN1dGFibGVKU09OJywgSlNPTi5wYXJzZShfZGF0YSksIHtcbiAgICAgICAgICAgICAgbm9UZXN0c0ZvdW5kLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcmV2TWVzc2FnZVR5cGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBtZXNzYWdlVHlwZXMud2F0Y2hVc2FnZTpcbiAgICAgIGNhc2UgbWVzc2FnZVR5cGVzLm5vVGVzdHM6XG4gICAgICAgIHRoaXMucHJldk1lc3NhZ2VUeXBlcy5wdXNoKG1zZ1R5cGUpO1xuICAgICAgICB0aGlzLmVtaXQoJ2V4ZWN1dGFibGVTdGRFcnInLCBkYXRhLCB7XG4gICAgICAgICAgdHlwZTogbXNnVHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gbm8gc3BlY2lhbCBhY3Rpb24gbmVlZGVkLCBqdXN0IHJlcG9ydCB0aGUgb3V0cHV0IGJ5IGl0cyBzb3VyY2VcbiAgICAgICAgaWYgKGlzU3RkRXJyKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdleGVjdXRhYmxlU3RkRXJyJywgZGF0YSwge1xuICAgICAgICAgICAgdHlwZTogbXNnVHlwZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyByZW1vdmUgY2xlYXIgc2NyZWVuIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICAgIHRoaXMuZW1pdCgnZXhlY3V0YWJsZU91dHB1dCcsIGRhdGEudG9TdHJpbmcoKS5yZXBsYWNlKCdcdTAwMWJbMkpcdTAwMWJbSCcsICcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmV2TWVzc2FnZVR5cGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBtc2dUeXBlO1xuICB9XG5cbiAgcnVuSmVzdFdpdGhVcGRhdGVGb3JTbmFwc2hvdHMoY29tcGxldGlvbjogKCkgPT4gdm9pZCwgYXJncz86IHN0cmluZ1tdKSB7XG4gICAgY29uc3QgZGVmYXVsdEFyZ3MgPSBbJy0tdXBkYXRlU25hcHNob3QnXTtcblxuICAgIGNvbnN0IHVwZGF0ZVByb2Nlc3MgPSB0aGlzLl9jcmVhdGVQcm9jZXNzKHRoaXMud29ya3NwYWNlLCBbLi4uZGVmYXVsdEFyZ3MsIC4uLihhcmdzIHx8IFtdKV0pO1xuICAgIHVwZGF0ZVByb2Nlc3Mub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgY29tcGxldGlvbigpO1xuICAgIH0pO1xuICB9XG5cbiAgY2xvc2VQcm9jZXNzKCkge1xuICAgIGlmICghdGhpcy5kZWJ1Z3Byb2Nlc3MgfHwgdGhpcy5fZXhpdGVkKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5sb2coYHByb2Nlc3MgaGFzIG5vdCBzdGFydGVkIG9yIGFscmVhZHkgZXhpdGVkYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAvLyBXaW5kb3dzIGRvZXNuJ3QgZXhpdCB0aGUgcHJvY2VzcyB3aGVuIGl0IHNob3VsZC5cbiAgICAgIHNwYXduKCd0YXNra2lsbCcsIFsnL3BpZCcsIGAke3RoaXMuZGVidWdwcm9jZXNzLnBpZH1gLCAnL1QnLCAnL0YnXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIGtpbGwgYWxsIHByb2Nlc3Mgd2l0aCB0aGUgc2FtZSBQR0lELCBpLmUuXG4gICAgICAgIC8vIGFzIGEgZGV0YWNoZWQgcHJvY2VzcywgaXQgaXMgdGhlIHNhbWUgYXMgdGhlIFBJRCBvZiB0aGUgbGVhZGVyIHByb2Nlc3MuXG4gICAgICAgIHByb2Nlc3Mua2lsbCgtdGhpcy5kZWJ1Z3Byb2Nlc3MucGlkKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaWYgYW55dGhpbmcgZ29lcyB3cm9uZywgZmFsbGJhY2sgdG8gdGhlIG9sZCBiZW5hdmlvclxuICAgICAgICAvLyBrbm93aW5nIHRoaXMgY291bGQgbGVhdmUgb3JwaGFuIHByb2Nlc3MuLi5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBmYWlsZWQgdG8ga2lsbCBwcm9jZXNzIGdyb3VwLCB0aGlzIGNvdWxkIGxlYXZlIHNvbWUgb3JwaGFuIHByb2Nlc3Mgd2hvc2UgcHBpZD0ke1xuICAgICAgICAgICAgdGhpcy5kZWJ1Z3Byb2Nlc3M/LnBpZCB8fCAncHJvY2Vzcy1ub24tZXhpc3QnXG4gICAgICAgICAgfS4gZXJyb3I9YCxcbiAgICAgICAgICBlXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZGVidWdwcm9jZXNzPy5raWxsKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGVidWdwcm9jZXNzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgZmluZE1lc3NhZ2VUeXBlKGJ1ZjogQnVmZmVyKTogTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0IG5vVGVzdFJlZ2V4ID0gL05vIHRlc3RzIGZvdW5kIHJlbGF0ZWQgdG8gZmlsZXMgY2hhbmdlZCBzaW5jZSAoKGxhc3QgY29tbWl0KXwoXCJbYS16MC05XStcIikpLi87XG4gICAgY29uc3Qgd2F0Y2hVc2FnZVJlZ2V4ID0gL15cXHMqV2F0Y2ggVXNhZ2VcXGIvO1xuICAgIGNvbnN0IHRlc3RSZXN1bHRzUmVnZXggPSAvVGVzdCByZXN1bHRzIHdyaXR0ZW4gdG8vO1xuXG4gICAgY29uc3QgY2hlY2tzID0gW1xuICAgICAge3JlZ2V4OiB0ZXN0UmVzdWx0c1JlZ2V4LCBtZXNzYWdlVHlwZTogbWVzc2FnZVR5cGVzLnRlc3RSZXN1bHRzfSxcbiAgICAgIHtyZWdleDogbm9UZXN0UmVnZXgsIG1lc3NhZ2VUeXBlOiBtZXNzYWdlVHlwZXMubm9UZXN0c30sXG4gICAgICB7cmVnZXg6IHdhdGNoVXNhZ2VSZWdleCwgbWVzc2FnZVR5cGU6IG1lc3NhZ2VUeXBlcy53YXRjaFVzYWdlfSxcbiAgICBdO1xuXG4gICAgY29uc3Qgc3RyID0gYnVmLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgY29uc3QgbWF0Y2ggPSBjaGVja3MuZmluZCgoe3JlZ2V4fSkgPT4gcmVnZXgudGVzdChzdHIpKTtcbiAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaC5tZXNzYWdlVHlwZSA6IG1lc3NhZ2VUeXBlcy51bmtub3duO1xuICB9XG5cbiAgZG9SZXN1bHRzRm9sbG93Tm9UZXN0c0ZvdW5kTWVzc2FnZSgpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5wcmV2TWVzc2FnZVR5cGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJldk1lc3NhZ2VUeXBlc1swXSA9PT0gbWVzc2FnZVR5cGVzLm5vVGVzdHM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJldk1lc3NhZ2VUeXBlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZXZNZXNzYWdlVHlwZXNbMF0gPT09IG1lc3NhZ2VUeXBlcy5ub1Rlc3RzICYmIHRoaXMucHJldk1lc3NhZ2VUeXBlc1sxXSA9PT0gbWVzc2FnZVR5cGVzLndhdGNoVXNhZ2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBd0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRXhDO0FBQ0E7QUFDQTtBQUFBLElBQ3FCQSxNQUFNO0VBQUE7RUFBQTtFQUt6Qjs7RUFHQTs7RUFhQTtFQUNBLGdCQUFZQyxTQUEyQixFQUFFQyxPQUFpQixFQUFFO0lBQUE7SUFBQTtJQUMxRDtJQUVBLE1BQUtDLGNBQWMsR0FBSUQsT0FBTyxJQUFJQSxPQUFPLENBQUNFLGFBQWEsSUFBS0Esc0JBQWE7SUFDekUsTUFBS0YsT0FBTyxHQUFHQSxPQUFPLElBQUksQ0FBQyxDQUFDO0lBQzVCLE1BQUtELFNBQVMsR0FBR0Es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